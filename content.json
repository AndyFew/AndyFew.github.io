{"meta":{"title":"AC_Dolphin's blog","subtitle":"此生无悔入OI","description":null,"author":"AC_Dolphin","url":"https://AndyFew.github.io"},"pages":[{"title":"标签","date":"2019-03-10T13:49:30.000Z","updated":"2019-03-10T13:55:23.336Z","comments":true,"path":"tags/index.html","permalink":"https://AndyFew.github.io/tags/index.html","excerpt":"","text":""},{"title":"关于...?","date":"2019-03-10T13:36:56.000Z","updated":"2019-03-10T13:54:11.749Z","comments":true,"path":"about/index.html","permalink":"https://AndyFew.github.io/about/index.html","excerpt":"","text":"菜鸡OIerLuoguCodeforces（太菜了）AtCoder（太菜了） 巨佬wyy（太巨了）"}],"posts":[{"title":"T4题解","slug":"T4题解","date":"2019-03-15T10:25:57.000Z","updated":"2019-03-15T12:48:55.426Z","comments":true,"path":"2019/03/15/T4题解/","link":"","permalink":"https://AndyFew.github.io/2019/03/15/T4题解/","excerpt":"","text":"题意：辗转相减你想到了什么？。。。gcd里面好像有这个算法对了这个题就是求这n个数的最大公约数所以就很简单了 Source:12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAXN=100010;int a[MAXN],n,cnt;int read()&#123; int f=1,x=0; char ch=getchar(); while(ch&lt;'0'||ch&gt;'9') &#123;if(ch=='-') f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9') &#123;x=x*10+ch-'0';ch=getchar();&#125; return f*x;&#125;int gcd(int a,int b)&#123; if(b==0) return a; return gcd(b,a%b);&#125;int main()&#123; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;a[i]; cnt=gcd(cnt,a[i]); &#125; cout&lt;&lt;cnt; return 0;&#125;","categories":[],"tags":[{"name":"E.P. 1","slug":"E-P-1","permalink":"https://AndyFew.github.io/tags/E-P-1/"}],"keywords":[]},{"title":"T3题解","slug":"T3题解","date":"2019-03-12T13:53:42.000Z","updated":"2019-03-12T13:58:11.209Z","comments":true,"path":"2019/03/12/T3题解/","link":"","permalink":"https://AndyFew.github.io/2019/03/12/T3题解/","excerpt":"","text":"一道看似是图论又不是图论的题（出数据的人太懒就1个数据点）定义：如果一个点的度为奇数，那么称这个点为奇点小学奥数：如果一个图有0或2个奇点，那么这个图可以一遍走过所有的道路而不重复，否则需加上(奇点的个数-2)/2条边可以一遍走过所有的道路而不重复所以代码就很简单了Source:123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAXN=100010;int a[MAXN],n,cnt,m;int main()&#123; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=m;i++)&#123; int x,y; cin&gt;&gt;x&gt;&gt;y; a[x]++; a[y]++; &#125; for(int i=1;i&lt;=n;i++)&#123; if(a[i]%2==1) cnt++; &#125; if(cnt==0||cnt==2) cout&lt;&lt;\"fuckccf\"; else &#123;cout&lt;&lt;\"ccf_is_a_shit\"&lt;&lt;endl; cout&lt;&lt;(cnt-2)/2;&#125; return 0;&#125;","categories":[],"tags":[{"name":"E.P. 1","slug":"E-P-1","permalink":"https://AndyFew.github.io/tags/E-P-1/"}],"keywords":[]},{"title":"T2题解","slug":"T2题解","date":"2019-03-12T13:50:56.000Z","updated":"2019-03-12T13:52:45.930Z","comments":true,"path":"2019/03/12/T2题解/","link":"","permalink":"https://AndyFew.github.io/2019/03/12/T2题解/","excerpt":"","text":"Solution 1:每次读入一个数，如果没有出现过就放进数组里，最后再把数组sort一遍就行了无代码 Solution 2:STL大法好！用set完美。。。Source:1234567891011121314151617#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAXN=100010;int a[MAXN],n,m;ll cnt;bool cmp(int a,int b)&#123; return a&gt;b;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i]; sort(a+1,a+n+1,cmp); for(int i=1;i&lt;=m;i++) cnt+=a[i]; cout&lt;&lt;cnt; return 0;&#125;","categories":[],"tags":[{"name":"E.P. 1","slug":"E-P-1","permalink":"https://AndyFew.github.io/tags/E-P-1/"}],"keywords":[]},{"title":"T1题解","slug":"T1题解","date":"2019-03-10T12:51:47.000Z","updated":"2019-03-12T05:13:02.234Z","comments":true,"path":"2019/03/10/T1题解/","link":"","permalink":"https://AndyFew.github.io/2019/03/10/T1题解/","excerpt":"","text":"巨水。。。既然是最大，那么我们想到把数组从大到小排序一遍，再取前m个数，就OK了Source:1234567891011121314151617#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAXN=100010;int a[MAXN],n,m;ll cnt;bool cmp(int a,int b)&#123; return a&gt;b;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i]; sort(a+1,a+n+1,cmp); for(int i=1;i&lt;=m;i++) cnt+=a[i]; cout&lt;&lt;cnt; return 0;&#125;","categories":[],"tags":[{"name":"E.P. 1","slug":"E-P-1","permalink":"https://AndyFew.github.io/tags/E-P-1/"}],"keywords":[]}]}